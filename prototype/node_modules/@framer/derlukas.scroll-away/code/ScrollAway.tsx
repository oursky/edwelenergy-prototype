import * as React from "react";
import { PropertyControls, ControlType, Frame } from "framer";

const noChildrenStyle: React.CSSProperties = {
  height: "100%",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  textAlign: "center",
  color: "#8855FF",
  background: "rgba(136, 85, 255, 0.1)",
  overflow: "hidden",
  fontSize: 12
};

interface Props {
  offset: number;
  tolerance: number;
  alignment: string;
  width: number;
  height: number;
  effect: string;
  hideDirection: string;
  transitionTime: number;
  transitionCurve: string;
  customCurve: string;
  scrollDirection: string;
  scrollPosition: number;
  pointOfChange: number;
}

interface State {
  visible: boolean;
}

let toleranceCounter = 0;

export class ScrollAway extends React.Component<Partial<Props>, State> {
  static defaultProps = {
    offset: 50,
    tolerance: 30,
    alignment: "flex-start",
    width: 300,
    height: 80,
    effect: "move",
    hideDirection: "top",
    transitionTime: 500,
    transitionCurve: "linear",
    customCurve: "cubic-bezier(.10, .10, .25, .90)",
    scrollDirection: "down",
    scrollPosition: 0,
    pointOfChange: 0
  };

  state = {
    visible: true
  };

  static propertyControls: PropertyControls = {
    offset: { type: ControlType.Number, title: "Offset" },
    tolerance: { type: ControlType.Number, title: "Tolerance" },
    alignment: {
      type: ControlType.SegmentedEnum,
      options: ["flex-start", "center", "flex-end"],
      optionTitles: ["Left", "Center", "Right"],
      defaultValue: "flex-start",
      title: "Alignment"
    },
    effect: {
      type: ControlType.Enum,
      options: ["move", "fade", "fade-move", "zoom"],
      optionTitles: ["Move", "Fade", "Fade Move", "Zoom"],
      title: "Effect"
    },
    hideDirection: {
      type: ControlType.SegmentedEnum,
      options: ["top", "down", "left", "right"],
      optionTitles: ["↑", "↓", "←", "→"],
      defaultValue: "top",
      title: "Direction",
      hidden(props) {
        return props.effect == "fade";
      }
    },
    transitionCurve: {
      type: ControlType.Enum,
      options: [
        "linear",
        "ease",
        "ease-in",
        "ease-out",
        "ease-in-out",
        "custom"
      ],
      optionTitles: [
        "linear",
        "ease",
        "ease-in",
        "ease-out",
        "ease-in-out",
        "Custom..."
      ],
      title: "Easing"
    },
    customCurve: {
      type: ControlType.String,
      title: "Custom",
      hidden(props) {
        return props.transitionCurve != "custom";
      }
    },
    transitionTime: {
      type: ControlType.Number,
      min: 0,
      max: 5000,
      unit: "ms",
      step: 50,
      title: "Timing"
    }
  };

  prevDirection = this.props.scrollDirection;
  componentWillReceiveProps(props: Props) {
    if (this.props.scrollPosition >= this.props.offset) {
      if (this.props.scrollDirection == "up") {
        toleranceCounter =
          this.props.pointOfChange + -this.props.scrollPosition;

        if (!this.state.visible && toleranceCounter >= this.props.tolerance) {
          this.setState({ visible: true });
        }
      } else {
        toleranceCounter =
          -this.props.pointOfChange + this.props.scrollPosition;

        if (this.state.visible && toleranceCounter >= this.props.tolerance) {
          this.setState({ visible: false });
        }
      }
    } else {
      this.setState({ visible: true });
    }

    this.prevDirection = this.props.scrollDirection;
  }

  render() {
    if (this.props.children.length > 0) {
      return (
        <Frame
          background="transparent"
          width={this.props.width}
          height={this.props.height}
          style={this.toggleVisibility()}
        >
          {this.props.children}
        </Frame>
      );
    } else {
      return (
        <div style={noChildrenStyle}>
          Connect to the frame you want to hide ⟶
        </div>
      );
    }
  }

  private toggleVisibility(): React.CSSProperties {
    let transition;
    if (this.props.transitionCurve == "custom") {
      transition = this.props.customCurve;
    } else {
      transition = this.props.transitionCurve;
    }
    if (this.props.effect == "move") {
      return this.state.visible
        ? {
            transition: `transform ${
              this.props.transitionTime
            }ms ${transition}`,
            transform: "translate3D(0, 0, 0)",
            display: "flex",
            justifyContent: this.props.alignment
          }
        : {
            transition: `transform ${
              this.props.transitionTime
            }ms ${transition}`,
            transform: this.hideDirection(),
            display: "flex",
            justifyContent: this.props.alignment
          };
    } else if (this.props.effect == "fade-move") {
      return this.state.visible
        ? {
            transition: `all ${this.props.transitionTime}ms ${transition}`,
            transform: "translate3D(0, 0, 0)",
            display: "flex",
            justifyContent: this.props.alignment,
            opacity: 1
          }
        : {
            transition: `all ${this.props.transitionTime}ms ${transition}`,
            transform: this.hideDirection(),
            display: "flex",
            justifyContent: this.props.alignment,
            opacity: 0
          };
    } else if (this.props.effect == "zoom") {
      return this.state.visible
        ? {
            transition: `all ${this.props.transitionTime}ms ${transition}`,
            transform: "scale3d(1,1,1)",
            display: "flex",
            justifyContent: this.props.alignment,
            opacity: 1
          }
        : {
            transition: `all ${this.props.transitionTime}ms ${transition}`,
            transform: "scale3d(.3,.3,.3)",
            display: "flex",
            justifyContent: this.props.alignment,
            opacity: 0
          };
    } else {
      return this.state.visible
        ? {
            transition: `opacity ${this.props.transitionTime}ms ${transition}`,
            opacity: 1,
            display: "flex",
            justifyContent: this.props.alignment
          }
        : {
            transition: `opacity ${this.props.transitionTime}ms ${transition}`,
            opacity: 0,
            display: "flex",
            justifyContent: this.props.alignment
          };
    }
  }

  private hideDirection(): string {
    switch (this.props.hideDirection) {
      case "right":
        return "translate3D(100%, 0, 0)";
        break;
      case "down":
        return "translate3D(0, 100%, 0)";
        break;
      case "left":
        return "translate3D(-100%, 0, 0)";
        break;
      default:
        return "translate3D(0, -100%, 0)";
    }
  }
}
